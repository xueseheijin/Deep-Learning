# -*- coding: utf-8 -*-
"""Task 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qEAeYVAcjlPQkkduPNwSzMkNjo4mpJcT
"""

#Part A
import numpy as np
import keras
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist
from matplotlib import pyplot as plt

# Load the MNIST dataset
(trainX, trainy), (testX, testy) = mnist.load_data()

# Select 12 samples from the training data
sample_indices = np.random.choice(trainX.shape[0], size=12, replace=False)
trainX_sample = trainX[sample_indices]
trainy_sample = trainy[sample_indices]

# Plot the samples and their labels
fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(12, 9))
for i, ax in enumerate(axes.flat):
    ax.imshow(trainX_sample[i], cmap='gray')
    ax.set_title("Label: {}".format(trainy_sample[i]))

plt.tight_layout()
plt.show()

# Preprocess the data
x_train_sample = trainX_sample / 255.0
x_test = testX / 255.0

# Split the data into training and validation sets
val_split = 0.1
val_index = int(x_train_sample.shape[0] * (1 - val_split))
x_val = trainX_sample[val_index:]
y_val = trainy_sample[val_index:]
x_train_sample = x_train_sample[:val_index]
y_train_sample = trainy_sample[:val_index]

print("Train Shape:", x_train_sample.shape, y_train_sample.shape)
print("Validation Shape:", x_val.shape, y_val.shape)
print("Test Shape:", x_test.shape, testy.shape)

#Part B
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Input
from tensorflow.keras.applications import VGG16

# Load the UAV dataset
(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()

# Preprocess the data
x_train = x_train / 255.0
x_test = x_test / 255.0

# Define Model A - a fully connected network
inputs = Input(shape=(28, 28, 1))
x = Flatten()(inputs)
x = Dense(128, activation='relu')(x)
x = Dense(64, activation='relu')(x)
outputs = Dense(2, activation='linear')(x)
model_A = Model(inputs, outputs)

# Compile Model A
model_A.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

# Train Model A
model_A.fit(x_train, y_train, batch_size=32, epochs=10, validation_data=(x_test, y_test))

# Define Model B - a YOLO network
inputs = Input(shape=(224, 224, 3))
vgg_model = VGG16(include_top=False, weights='imagenet', input_tensor=inputs)
for layer in vgg_model.layers:
    layer.trainable = False
x = vgg_model.output
x = Flatten()(x)
x = Dense(1024, activation='relu')(x)
outputs = Dense(2, activation='linear')(x)
model_B = Model(inputs, outputs)

# Compile Model B
model_B.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

# Train Model B